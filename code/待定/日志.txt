调车日志

2023.1.9
/////////////////////////////////////////////////////
1.GPS数据是否正常传输，在GPS_INIT中，有一个 set_wireless_type(GPS_TAU1201, gps_uart_callback);在gps_uart_callback)中会将gps_tau1201_flag置1
  即GPS初始化完成后，gps_tau1201_flag=1

2.GPS数据解析，在初始化成功后，解析函数会对正常传输的数据进行解析，可得到我们的经纬度信息。

3.整个程序里面数据解析只需要一个就行了，放在主循环里面，放上放下都无所谓
  路线:
       1.FLASH问题未解决，先尝试用数组手动存点
       2.flash采点可以用，存点不能用
       3.flash采点并存储
       
2023.1.10
/////////////////////////////////////////////////////
1.虽然数组存点和FLASH存点都能存点，但是FLASH可以掉电保存，数组则不行，但是在比赛中不是存完电就能跑的，可能会要求断电等等，所以程序中并没有什么要求
  必须重新上电才能运行，只是赛事规则可能要求断电
  
2.当车辆实时位置和目标点位小于三米时切换到下一个目标点，当车速非常快的时候，就近似于到那个点了，这样处理时防止车辆为了精准而一直围绕这目标点转圈
  
2023.1.11
/////////////////////////////////////////////////////
1.FLASH存点程序的卡住问题:具体表现为当按键进入程序后，实时值和缓冲区的值不变，不按键时实时值会变。
  经过分段注释之后发现问题，问题出在全局中断失能和使能上。将其注释掉能完成目标功能。
  
2.采集和存取点流程:/把数据存到缓冲区/在判断FLASH里有没有数据，有就把FLASH擦除/把缓冲区数据存到FLASH
  将FLASH的点位信息存到点位数组:/清空缓冲区/判断FLASH里有没有数据，有就将FLASH的数据重新读会缓冲区/将缓冲区的数据通过循环存取到点位数组
  
3.拨码开关拨到上面是0，下面是1  
  
2023.1.12
/////////////////////////////////////////////////////
1.IMU660--角速度计(陀螺仪) / 加速度计   GPS-方位角   IMU-航向角(yaw)

2.固定坐标系(导航系)  载体坐标系(载体系，固定在载体上的坐标系)

3.转向原理:首先我们以正北方向为0点(注意！IMU安装的在车子的中心位置附近，发车时应该将车子车头对准正北按下上电/校准)
          已知GPS提供方位角，IMU提供航向角，二者均以正北为0点，在车子由实际点向目标点行进时，实际点和目标点的方向角不断变化，而IMU的航向角也相对于正北不断变化
          可以利用实时的（方位角-航向角)=角度误差，将角度误差进到PD，理想情况下可以使车子完成转向目标
          
4.陀螺仪面向正北重新上电，然后当yaw的值接近0，将flash数据复制到缓存数组就可以跑了(他是这么说的)          
          
2023.1.13
/////////////////////////////////////////////////////
1.未验证程序:Motor_and_steer.c
            Motor_ctrl.c
         

2023.1.30
/////////////////////////////////////////////////////  
1.工程太大了，好累
  
2023.1.31
/////////////////////////////////////////////////////  
1.我终于参透了符文，这里太小我写不下
  
 2023.2.01
//////////////////////////////////////////////////// 
1.首先是菜单问题，在参考哈工大和内工大的菜单后，发现其是用链表思路，太难了，而我现在这个是在CSDN上移植的一个三级菜单(数组查表法)，后来发现和晋仁磊的菜单
  大同小异，说明移植于同一份代码。 
  
2.理解本代码，需要基本的结构体和指针的知识，特别是结构体数组，切记结构体数组中的每一个元素都是结构体，可以调用结构体中的成员，这就是为什么这个程序巧妙的原因
  
2023.2.02
////////////////////////////////////////////////////
//const uint8 chinese_HXCD[8][16] 
//{
//        {0x01,0x00,0x21,0x00,0x11,0xFC,0x12,0x00,0x85,0xF8,0x41,0x08,0x49,0x48,0x09,0x28},
//        {0x17,0xFE,0x11,0x08,0xE2,0x48,0x22,0x28,0x23,0xFC,0x20,0x08,0x20,0x50,0x00,0x20},/*"海",0*/
//
//        {0x44,0x00,0x25,0xDC,0x28,0x44,0xFE,0x44,0x11,0x54,0x10,0xCC,0x7C,0x44,0x10,0x44},
//        {0x10,0x4C,0xFE,0xD4,0x11,0x64,0x10,0x44,0x20,0x44,0x20,0x44,0x41,0x54,0x80,0x88},/*"翔",1*/
//
//        {0x08,0x20,0x08,0x20,0xFF,0xFE,0x08,0x20,0x00,0x10,0x00,0xF8,0x3F,0x00,0x11,0x10},
//        {0x08,0x20,0x01,0x00,0x7F,0xFC,0x05,0x40,0x09,0x20,0x31,0x18,0xC1,0x06,0x01,0x00},/*"菜",2*/
//
//        {0x10,0x10,0x08,0x20,0x04,0x40,0x3F,0xF8,0x21,0x08,0x21,0x08,0x3F,0xF8,0x21,0x08},
//        {0x21,0x08,0x3F,0xF8,0x01,0x00,0x01,0x00,0xFF,0xFE,0x01,0x00,0x01,0x00,0x01,0x00},/*"单",3*/
//
//
//};

2023.2.04
////////////////////////////////////////////////////
1.解决位置式PD的加减与存储，电机PI与此大同小异，思路:将PD(KP=0/KD=1)和PI(KP=2,KI=3),放入缓冲区，分别为[0][1][2][3],按顺序存入FLASH,则读取时按顺序读取，
  而后依次赋值给参数结构体成员，达到复位生效的效果。

2023.2.05
////////////////////////////////////////////////////
1.本菜单储存参数(复位生效思路)，通过在特定函数里，执行存值程序，然后在初始化里将值覆写上一次的值即可达到目的
2，如果在每个参数初始化函数下面加入清除FLASH函数，则会导致每次改值只能维持一次，然后需要重新输入，目前来看SPEED有点BUG，必须要保证改值的时候，清除掉FALSH，才可以改值

2023.2.11
////////////////////////////////////////////////////
本车的参考坐标系均以正北，所有的角度误差都是与正北相关

2023.2.28
////////////////////////////////////////////////////
对于GPS的点位的一些思路
1.GPS的采集速率是10HZ,所以我可以采集20个点位,取得均值点
2.然后计算20个实际点位和均值点得距离,冒泡滤波去掉最大的几个实际点位
3.将剩下的实际点位重新均值,得到实际的均值点,参与计算




2023.3.22
//1.慎清缓冲区，对于需要记录多次记录数值的,务必思考清楚存储流程
  2.第二版代码读GPS数据出现乱码就是因为在菜单采集点位的时候，每次采集都清空缓冲区，导致实际上存到FlASH里的是最后一次存储的数据，所以导致前面的数据读出来是---nan
  3.进而我们可以知道实际上用不到这么多页区，之前没懂的毛病也已经明确。
  
2023.3.29
//1.经过今天的测试，发现一个问题，在经度不变的情况下，会产生较大误差，但如果经度改变则误差相对较小
  2.车的机械误差的解决方法，可以通过修改中值的方式来解决弥补机械误差，车正常境况下会向右边偏移，则加上向左的角度修正。

2023.3.31
//1.彻底解决存速度卡死的问题，原因是按键多用设置不合理，用完拨码开关后，可能会影响其他的东西导致奇怪的问题，现在将发车移到菜单别的地方彻底解决问题
  2.突破进展:当经度不变时，方位角为0，由于我的IMU偏移并不大，所以在修正车模机械误差之后，效果明显变好，在添加IMU抑制并经过PID运算后，参数合适，此时车模情况明显更好
            问题在于如何在一条直线保持经度相同，目前看到，每次经度变化都会导致车体拐一个相对较大的角，是需要解决的问题。

2023.4.04
//1.更改GPS所用串口，改为串口0，不仅需要更改串口号，而且需要将串口回调函数放到指定串口，然后拔掉下载线   

2023.4.13
//1.用int定义的数组存浮点数的话，则只能存起整数部分，导致损失精度   

2023.4.16
//1.GPS数据中，RMC和GGA语句是两种常见的语句
    RMC语句代表Recommended Minimum Navigation Information（推荐最小导航信息），包含了关于时间、日期、位置、速度等方面的信息。下面是一个RMC语句的示例：
    $GPRMC,123519.00,A,4330.0000,N,07200.0000,W,0.1,87.0,230394,003.1,W*6A
    其中，$GPRMC是语句标识符，123519.00代表UTC时间，A代表定位有效（也可能是V，代表无效），4330.0000 N和07200.0000 W代表纬度和经度信息，0.1代表速度，87.0代表航向，230394代表日期（23日03月94年），003.1 W代表磁偏角和磁偏角方向。
    GGA语句代表Global Positioning System Fix Data（全球定位系统定位数据），包含了关于卫星数量、位置、海拔高度等方面的信息。下面是一个GGA语句的示例：
    $GPGGA,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*47
    其中，$GPGGA是语句标识符，123519代表UTC时间，4807.038 N和01131.000 E代表纬度和经度信息，1代表GPS定位质量指示（0：无效，1：单点定位，2：差分定位，4：实时差分，5：RTK固定解，6：RTK浮动解），08代表使用卫星的数量，0.9代表高程角度和单位（米），545.4 M代表大地高度和单位（米），46.9 M代表地球椭球面高度和单位（米）。
    这些信息对于导航、地图服务等应用非常有用。在解析GPS数据时，需要根据具体应用场景和需求提取相关信息，并进行相应的数据处理和计算。 
     
2023.4.17
    ////        ips_show_string(0, 16*0,"latitude_R:");     ips_show_float(100, 16*0, Work_target_array[0][0],4, 6);
    //        ips_show_string(0, 16*1,"longitude_R:");    ips_show_float(100, 16*1, Work_target_array[1][0],4, 6);
    //
    //        ips_show_string(0, 16*2,"latitude_R:");     ips_show_float(100, 16*2, Work_target_array[0][1],4, 6);
    //        ips_show_string(0, 16*3,"longitude_R:");    ips_show_float(100, 16*3, Work_target_array[1][1],4, 6);
    //
    //        ips_show_string(0, 16*4,"latitude_R:");     ips_show_float(100, 16*4, Work_target_array[0][2],4, 6);
    //        ips_show_string(0, 16*5,"longitude_R:");    ips_show_float(100, 16*5, Work_target_array[1][2],4, 6);
    //
    //        ips_show_string(0, 16*6,"latitude_R:");     ips_show_float(100, 16*6, Work_target_array[0][3],4, 6);
    //        ips_show_string(0, 16*7,"longitude_R:");    ips_show_float(100, 16*7, Work_target_array[1][3],4, 6);
    //
    //        ips_show_string(0, 16*8,"latitude_R:");     ips_show_float(100, 16*8, Work_target_array[0][4],4, 6);
    //        ips_show_string(0, 16*9,"longitude_R:");    ips_show_float(100, 16*9, Work_target_array[1][4],4, 6);
    //
    //        ips_show_string(0, 16*10,"latitude_R:");     ips_show_float(100, 16*10, Work_target_array[0][5],4, 6);
    //        ips_show_string(0, 16*11,"longitude_R:");    ips_show_float(100, 16*11, Work_target_array[1][5],4, 6);
    //
    //        ips_show_string(0, 16*12,"latitude_R:");     ips_show_float(100, 16*12, Work_target_array[0][9],4, 6);
    //        ips_show_string(0, 16*13,"longitude_R:");    ips_show_float(100, 16*13, Work_target_array[1][9],4, 6);
    
2023.4.18
//1.在TC264中的两个核心，实际上他们的流水线数量是不一样的，CPU0是一级流水线，CPU1是三级流水线，因此CPU1更适合做运算，速度会比CPU0快一些。 
//2.逐飞GPS回传的数据只能精确到小数点后6位

2023.5.12
//1.逐飞说的整数存储在计算的时候会发生:逐飞给的自定义数学函数会导致程序卡死，现在准备使用软件浮点运算

2023.5.14
//1.封启航拨码开关下面是1，上面是0
    
    
    
    
    if(x6f_out[3]>150)
    {
        if(x6f_out[1]>170)
        {
          Task_RZT (62,50);
        }
        else
        {
          IMU_Navigation_180(); //IMU--180度导航
        }

    }
    else
    {
           IMU_Navigation_0();//IMU--0度导航
    }
2023.7.16
//登神长阶我能走过嘛？比赛结束以后我在来回答   
    
 //    if(x6f_out[3]>150)
//    {
//
//          IMU_Navigation_180_N(); //IMU--180度导航
//
//
//    }
//    else
//    {
//        if(x6f_out[1]>170)
//        {
//            Task_RZT (55,2000,180,'N');
//        }
//        else
//        {
////          IMU_Navigation_180_S(); //IMU--180度导航
//            IMU_Navigation_0();//IMU--0度导航
//        }
//    }